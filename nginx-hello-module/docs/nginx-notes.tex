\documentclass{beamer}

\usepackage[utf8x]{inputenc}
\usepackage{default}

\title{Nginx Notes}
\author{Paolo D'Apice}
\institute{iZENEsoft (Shanghai) Co. Ltd.}
\logo{\includegraphics[scale=.5]{izene.png}}
\date{\today}

\beamertemplatenavigationsymbolsempty

\begin{document}

\begin{frame}
 \maketitle
\end{frame}

\section{Nginx}

\begin{frame}{What's Nginx}{A definition}
\begin{figure}
\includegraphics[scale=.4]{nginx.png}
\end{figure}
\begin{quote} \small
Apache is like Microsoft Word, it has a million options but you only need six. \\
Nginx does those six things, and it does five of them 50 times faster than Apache.
\end{quote}
\begin{flushright}
Chris Lea 
\end{flushright}
\end{frame}

\begin{frame}{What's Nginx}{Another definition}
\begin{figure}
\includegraphics[scale=.125]{batman.png}
\end{figure}
\begin{quote} \small
Batman is fast. Nginx is fast.\\
Batman fights crime. Nginx fights wasted CPU cycles and memory leaks.\\
Batman performs well under pressure. Nginx, for its part, excels under heavy server loads.\\
\ \\
But Batman would be almost nothing without the Batman utility belt.
Instead of a utility belt, Nginx has a module chain.
\end{quote}
\begin{flushright}
Evan Miller 
\end{flushright}
\end{frame}

\begin{frame}{How it works}{Modules}
Module types:
\begin{description}
 \item[handlers] process a request and produce an output
 \item[filters] manipulate the output produced by a handler
 \item[load-balancers] forward a request choosing between multiple backend servers
\end{description}
\end{frame}

\section{Nginx Modules}

\begin{frame}{Components}
 \begin{enumerate}
  \item configuration structs
  \item directives
  \item context
  \item definition
  \item installation
 \end{enumerate} 
\end{frame}

\begin{frame}{Components}{Configuration structs}
 \begin{itemize}
  \item up to three
  \begin{itemize}
   \item main
   \item server
   \item location
  \end{itemize}
  \item populated by module directives
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Components}{Directives}
 \begin{itemize}
  \item array of \verb|ngx_command_t| structs
  \item used for module configuration
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Components}{Context}
 \begin{itemize}
  \item an \verb|ngx_http_module_t| struct
  \item contains function references for creating and merging configurations
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Components}{Definition}
 \begin{itemize}
  \item an \verb|ngx_module_t| struct named \verb|ngx_<module name>_module|
  \item contains references to context, directives and other callbacks
 \end{itemize}
\end{frame}

\begin{frame}{Components}{Installation}
\begin{itemize}
 \item depends on the module type 
 \item see later \ldots
\end{itemize}
\end{frame}

\subsection{Handlers}

\begin{frame}{Handlers}
Typically do four things:
\begin{enumerate}
 \item get location configuration
 \item generate appropriate response
 \item send response header
 \item send response body
\end{enumerate}
\end{frame}

\begin{frame}{Handlers}{Upstream Handlers (Proxy)}
\begin{itemize}
 \item do little "real work"
 \item callbacks invoked when the upstream is ready
\end{itemize}
\end{frame}

\begin{frame}{Handlers}{Installation}
\begin{itemize}
 \item define the directive that enables the module
 \item get the "core" struct for the location
 \item assign a handler to it
\end{itemize}
\end{frame}

\subsection{Filters}

\begin{frame}{Filters}
Manipulate responses generated by handlers
\begin{itemize}
 \item header filters
 \item body filters
\end{itemize}
\end{frame}

\begin{frame}{Filters}{Header filters}
Three basic steps:
\begin{enumerate}
\item decide whether to operate on the response
\item operate on the response
\item call the next filter
\end{enumerate}
\end{frame}

\begin{frame}{Filters}{Body filters}
\begin{itemize} 
 \item operate only on one buffer (chain link) at a time
 \begin{itemize}
  \item overwrite
  \item replace
  \item insert new buffer before/after
 \end{itemize}
 \item support incomplete buffer chain
 \item no nice high-level API
\end{itemize}
\end{frame}

\begin{frame}{Filters}{Installation}
\begin{itemize}
 \item post-configuration step
 \item insert the filter on the top of filter chain (LIFO)
\end{itemize}
\end{frame}

\subsection{Load-Balancer}

\begin{frame}{Load-Balancer}
Decide which backend server will receive a particular request
\begin{enumerate}
 \item enabling configuration directive
 \item registration function
 \item upstream initialization function
 \item peer initialization function
 \item load balancing function
 \item peer release function
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Load-Balancer}{enabling directive}
\begin{itemize}
 \item should have the \verb|NGX_UPS_CONF| flag set
 \item provide a pointer to a \emph{registration function}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Load-Balancer}{registration function}
\begin{itemize}
 \item define options within the \verb|upstream| configuration
 \item register an \emph{upstream initialization function}
\end{itemize}
\end{frame}

\begin{frame}{Load-Balancer}{upstream initialization function}
\begin{itemize}
 \item resolves the server names
 \item allocates sockets
 \item sets a callback to the \emph{peer initialization function}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Load-Balancer}{peer initialization function}
\begin{itemize}
 \item called \emph{once} per request
 \item sets up data structures used by the \emph{load balancing function}
 \begin{itemize}
  \item struct named \verb|ngx_http_upstream_<module>_peer_data_t|
 \end{itemize}
 \item sets up two callbacks
 \begin{description}
  \item[get] the \emph{load-balancing function}
  \item[free] the \emph{peer release function}
 \end{description}
\end{itemize}
\end{frame}

\begin{frame}{Load-Balancer}{load balancing function}
\begin{itemize}
 \item called \emph{at least} per request
 \item defines the load-balancing policy using sockets
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Load-Balancer}{peer release function}
\begin{itemize}
 \item operates after the upstream connection take place
 \item at least must set \verb|pc->tries| to zero
\end{itemize}
\end{frame}

\section{Writing Nginx Modules}
 
\begin{frame}{Writing Nginx Modules}
\begin{itemize}
 \item no or little documentation
 \begin{itemize}
  \item mostly in Russian or Chinese
  \item \emph{self documented} source code
 \end{itemize}
 \item learn by example
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Writing Nginx Modules}
\begin{itemize}
 \item write you code
 \item write a \verb|config| file
 \item compile Nginx with your module
\end{itemize}
\end{frame}

\begin{frame}{Writing Nginx Modules}
\begin{itemize}
 \item take a look at the hello-module
 \begin{itemize}
  \item autotools adapted to CMake
  \item C++ support\footnote{Nginx is written in plain C}
  \item Test::Nginx Perl framework
 \end{itemize}
\item stick to the naming standards
\end{itemize}
\end{frame}

\section{References}

\begin{frame}{References}
\begin{thebibliography}{10}
 \bibitem{wiki} Nginx Wiki 
  \newblock \url{http://wiki.nginx.org/Main}
 \bibitem{emiller} Evan Miller's \emph{definitive} guide 
  \newblock \url{http://www.evanmiller.org/nginx-modules-guide.htm}
 \bibitem{discovery} Antoine Bonavita's blog about Nginx
  \newblock \url{http://www.nginx-discovery.com}
\end{thebibliography}
\end{frame}

\begin{frame}{More References}
\begin{thebibliography}{10}
 \bibitem{tengine} Taobao's Tengine
  \newblock \url{http://tengine.taobao.org}
 \bibitem{agentz} agentz's blog
  \newblock \url{http://agentzh.org}
 \bibitem{chaoslawful} chaoslawful's blog
  \newblock \url{http://chaoslawful.iteye.com}
 \bibitem{zhu} Joshua Zhuâ€™s blog
  \newblock \url{http://blog.zhuzhaoyuan.com}
\end{thebibliography}
 
\end{frame}


\end{document}
