\documentclass{beamer}

\usepackage[utf8x]{inputenc}
\usepackage{default}

\title{Nginx Notes}
\author{Paolo D'Apice}
\institute{iZENEsoft (Shanghai) Co. Ltd.}
\logo{\includegraphics[scale=.5]{izene.png}}
\date{\today}

\beamertemplatenavigationsymbolsempty

\begin{document}

\begin{frame}
 \maketitle
\end{frame}

\section{Nginx}

\begin{frame}{What's Nginx}{A definition}
\begin{figure}
\includegraphics[scale=.4]{nginx.png}
\end{figure}
\begin{quote} \small
Apache is like Microsoft Word, it has a million options but you only need six. \\
Nginx does those six things, and it does five of them 50 times faster than Apache.
\end{quote}
\begin{flushright}
Chris Lea 
\end{flushright}
\end{frame}

\begin{frame}{What's Nginx}{Another definition}
\begin{figure}
\includegraphics[scale=.125]{batman.png}
\end{figure}
\begin{quote} \small
Batman is fast. Nginx is fast.\\
Batman fights crime. Nginx fights wasted CPU cycles and memory leaks.\\
Batman performs well under pressure. Nginx, for its part, excels under heavy server loads.\\
\ \\
But Batman would be almost nothing without the Batman utility belt.
Instead of a utility belt, Nginx has a module chain.
\end{quote}
\begin{flushright}
Evan Miller 
\end{flushright}
\end{frame}

\begin{frame}{How it works}{Modules}
Module types:
\begin{description}
 \item[handlers] process a request and produce an output
 \item[filters] manipulate the output produced by a handler
 \item[load-balancers] forward a request choosing between multiple backend servers
\end{description}
\end{frame}

\section{Nginx Modules}

\begin{frame}{Components}
 \begin{enumerate}
  \item configuration
  \item directives
  \item context
  \item definition
  \item installation
 \end{enumerate} 
\end{frame}

\begin{frame}{Module Configuration Struct(s)}
 \begin{itemize}
  \item up to three
  \begin{itemize}
   \item main
   \item server
   \item location
  \end{itemize}
  \item elements in the structs are populated by module directives
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Module Directives}
 \begin{itemize}
  \item array of \verb|ngx_command_t| structs
  \item used for module configuration
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Module Context}
 \begin{itemize}
  \item an \verb|ngx_http_module_t| struct
  \item contains function references for creating and merging configurations
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Module Definition}
 \begin{itemize}
  \item an \verb|ngx_module_t| struct named \verb|ngx_<module name>_module|
  \item contains references to context, directives and other callbacks
 \end{itemize}
\end{frame}

\begin{frame}{Module installation}
\begin{itemize}
 \item depends on the module type 
 \item see later \ldots
\end{itemize}
\end{frame}

\subsection{Handlers}

\begin{frame}{Handlers}
Typically do four things:
\begin{enumerate}
 \item get location configuration
 \item generate appropriate response
 \item send response header
 \item send response body
\end{enumerate}
\end{frame}

\begin{frame}{Handlers}{Upstream Handlers (Proxy)}
\begin{itemize}
 \item do little "real work"
 \item callbacks invoked when the upstream is ready
\end{itemize}
\end{frame}

\begin{frame}{Handlers}{Installation}
\begin{itemize}
 \item define the directive that enables the module
 \item get the "core" struct for the location
 \item assign a handler to it
\end{itemize}
\end{frame}

\subsection{Filters}

\begin{frame}{Filters}
Manipulate responses generated by handlers
\begin{itemize}
 \item header filters
 \item body filters
\end{itemize}
\end{frame}

\begin{frame}{Filters}{Header filters}
Three basic steps:
\begin{enumerate}
\item decide whether to operate on the response
\item operate on the response
\item call the next filter
\end{enumerate}
\end{frame}

\begin{frame}{Filters}{Body filters}
\begin{itemize} 
 \item operate only on one buffer (chain link) at a time
 \begin{itemize}
  \item overwrite
  \item replace
  \item insert new buffer before/after
 \end{itemize}
 \item support incomplete buffer chain
 \item no nice high-level API
\end{itemize}
\end{frame}

\begin{frame}{Filters}{Installation}
\begin{itemize}
 \item post-configuration step
 \item insert the filter on the top of filter chain (LIFO)
\end{itemize}
\end{frame}

\subsection{Load-Balancer}

\begin{frame}{Load-Balancer}
TODO 
\end{frame}

\section{Writing Nginx Modules}

\begin{frame}{Writing Nginx Modules}
\begin{itemize}
 \item no or little documentation
 \begin{itemize}
  \item mostly in Russian or Chinese
  \item \emph{self documented} source code
 \end{itemize}
 \item learn by example
\end{itemize}
\end{frame}

\begin{frame}{Writing Nginx Modules}
\begin{itemize}
 \item write you code
 \item write a \verb|config| file
 \item compile Nginx with your module
\end{itemize}

\end{frame}

\begin{frame}{Writing Nginx Modules}
\begin{itemize}
 \item take a look at the hello-module
 \begin{itemize}
  \item autotools adapted to CMake
  \item C++ support\footnote{Nginx is written in plain C}
  \item Test::Nginx Perl framework
 \end{itemize}
\item stick to the naming standards
\end{itemize}
\end{frame}

\section{References}

\begin{frame}{References}
\begin{thebibliography}{10}
 \bibitem{wiki} Nginx Wiki 
  \newblock \url{http://wiki.nginx.org/Main}
 \bibitem{emiller} Evan Miller's \emph{definitive} guide 
  \newblock \url{http://www.evanmiller.org/nginx-modules-guide.htm}
\end{thebibliography}

\end{frame}


\end{document}
